# 알고리즘 시간복잡도에 대하여. 
# 문제를 풀다가 시간복잡도를 계산 못해서 자꾸 시간 초과가 난다. 중요한 것 같아서 자료를 찾아보았다.

시간복잡도

방을 정리한다고 해보자. 방에 널려 있는 물건의 양에 따라 정리에 걸리는 시간이 달라질 것이다. 프로그램을 작성할 때에도 입력의 크기에 따라서 프로그램이 계산하는 횟수가 크게 달라진다. 입력된 자료의 양과 알고리즘 실행에 걸리는 시간 사이에는 어느 정도의 관계가 있다. 이것을 알고리즘의 시간 복잡도라 한다.

[소스1]
res = 0
N = int(input())
 
for i in range(1,N+1) : 
    res += i 
 
print(res)

[소스2]
N = int(input())
res = N * (N+1) // 2
 
print(res)

소스 1에서는 for문을 활용하여 직접 res에 1에서 N까지를 더해서 합을 계산했다. 
소스 2에서는 임의의 수 N에 대하여 res에 N*(N+1) // 2 의 값을 대입했다.

소스 1의 경우에는 N이 1000이라면 덧셈이 1000번 일어나고 N이 100000이라면 덧셈이 100000번 일어난다. 즉, 계산하는 횟수가 N에 비례한다는 것이다.
반면, 소스2의 경우에는 N이 1000이든 1000000이든 계산이 총 1번만 일어난다.

모든 알고리즘은 이와같이 입력되는 데이터의 크기, 또는 갯수에 따라 이의 계산 횟수 수행시간이 크게 달라지게 된다. 입력 받는 데이터의 크기에 따른 	알고리즘의 수행시간의 변화가 시간복잡도이다. 시간복잡도가 더 큰 알고리즘들은 더 큰, 혹은 많은 데이터를 처리할 때 훨씬 더 오랜 시간이 걸리게된다. 그러나 이런 계산 횟수의 정확한 측정이 어렵기 때문에 보통 Big O 표기법이라는 것을 이용하여 표현한다.


시간복잡도를 표현할 때에는 계산 횟수에 붙은 상수는 별로 중요하지 않다. 시간복잡도에 붙은 상수가 무색할 정도로 n이 커지면, 그 때는 n이 커짐에 따라 증가하는 계산 횟수가 훨씬 더 중요해진다. 즉 n번 계산하든, 12938n번 계산하든, 239n+19293 번 계산하든 모두
O(n)으로 표기하는 것이다. 예를 들어
3n+2n3+12334n2+33nlogn+13123번 계산하는 알고리즘의 시간복잡도는 
O(2n)으로 나타낼 수 있다. 근데 왜 여기서 O(3n) 으로 나타내지 않는 이유는 
3n도 O표기법으로는2n와 같다. 물론 14500n 도 같은 시간복잡도를 나타내는 것이지만 가장 간단하게 2n 으로 표기한다. 

아래는 자주 등장하는 시간복잡도들의 표이다. 위의 알고리즘이 가장 시간복잡도가 낮은, 즉 가장 빠른 알고리즘이라 부르고, 아래의 알고리즘이 가장 시간 복잡도가 높은, 즉 가장 느린 알고리즘이라고 부른다.
시간 복잡도
설명
O(1)
상수 형태. n의 값과 무관하게 일정한 값 계산
O(logn)
로그 형태
O(n)
선형 형태
O(nlogn)
선형로그 형태
O(n2), O(n3) , …
다차 형태
O(2n)
지수 형태
O(n!)
팩토리얼 형태

프로그래밍 대회에서는 문제를 풀 때 프로그램 수행시간에 제한이 있기 때문에, 일정한 시간 복잡도 이하가 되어야 정답 판정이 된다. 이 때 필요한 시간 복잡도를 대략 계산해 보려면 문제에서 N의 제한을 보면된다. 내가 직접 짠 프로그램의 시간 복잡도에 실제 N의 제한을 넣어보자. 이 수가 대략 1천만 ~ 10억 사이일 때 대략 1초의  시간 제한에 맞는 프로그램이라 할 수 있다. 만약, 프로그램의 시간 복잡도가 O(n2logn)이고 n의 제한이 
n <=1,000 이라하면 이 때 n의 제한인 1,000을 실제 식에 넣어 보는 것이다. 
10002log1000 = 10,000,000이므로, 상수가 너무 크지 않으면, 즉 안에 들어가 있는 계산량이 너무 많지 않은 이상은 1초의 시간제한 안에 들어가게 될 것이다.

N의 범위가 500인 경우 : 시간 복잡도가 O(n3)인 알고리즘을 설계
N의 범위가 2,000인 경우: 시간 복잡도가 O(n2)인 알고리즘을 설계
N의 범위가 100,000인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설계
N의 범위가 10,000,000인 경우 : 시간 복잡도가 O(N)인 알고리즘을 설계

int a[1000] : 4KB
int a[1000000] : 4MB			→ 공간복잡도
int a[2000][2000] : 16MB

출처 : https://librewiki.net/wiki/%EC%8B%9C%EB%A6%AC%EC%A6%88:%EC%88%98%ED%95%99%EC%9D%B8%EB%93%AF_%EA%B3%BC%ED%95%99%EC%95%84%EB%8B%8C_%EA%B3%B5%ED%95%99%EA%B0%99%EC%9D%80_%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%BC%ED%95%99/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EA%B8%B0%EC%B4%88
